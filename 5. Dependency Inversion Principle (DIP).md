# **Dependency Inversion Principle (DIP) in Detail with C# Example**

---

## **Understanding the Dependency Inversion Principle (DIP)**

### **Definition:**
The **Dependency Inversion Principle (DIP)** states:  

1. High-level modules should not depend on low-level modules. Both should depend on abstractions.  
2. Abstractions should not depend on details. Details should depend upon abstractions.  

In simpler terms, rather than a class depending directly on another concrete class, it should depend on an interface or an abstract class. This keeps the code flexible, maintainable, and testable.

---

## **Real-World Analogy: Power Sockets & Plugs**
Think about the electrical socket in your house:

- The **socket** represents a **high-level module**.
- The **plug** represents a **low-level module**.
- The **socket should not depend on a specific brand of plug**; instead, both should adhere to a standard interface (e.g., a universal power standard).  

By following this standard (abstraction), any brand’s plug can be used in the socket without modifying the socket itself.

---

## **C# Example: Without DIP (Bad Design)**
Here’s an example where a `Laptop` class directly depends on a `WiredCharger` class.

```csharp
public class WiredCharger  
{  
    public void ChargeLaptop()  
    {  
        Console.WriteLine("Laptop is charging with a wired charger.");  
    }  
}  

public class Laptop  
{  
    private WiredCharger _charger;  

    public Laptop()  
    {  
        _charger = new WiredCharger();  // Direct dependency on a concrete class
    }  

    public void Charge()  
    {  
        _charger.ChargeLaptop();  
    }  
}  

class Program  
{  
    static void Main()  
    {  
        Laptop laptop = new Laptop();  
        laptop.Charge();  
    }  
}  
```

### **Problems in the Above Code:**
1. **Tightly Coupled:** The `Laptop` class directly depends on `WiredCharger`, making it difficult to replace with a different charger type (e.g., WirelessCharger).
2. **Difficult to Extend:** If we need to support multiple chargers (e.g., wireless charger), we must modify the `Laptop` class.
3. **Not Testable:** We cannot easily mock the `WiredCharger` for unit testing.

---

## **Applying DIP: Using Abstraction (Interfaces)**
Let's refactor the code using the **Dependency Inversion Principle**.

```csharp
// Step 1: Define an Abstraction (Interface)
public interface ICharger  
{  
    void ChargeDevice();  
}  

// Step 2: Implement Different Charger Types
public class WiredCharger : ICharger  
{  
    public void ChargeDevice()  
    {  
        Console.WriteLine("Charging with a wired charger.");  
    }  
}  

public class WirelessCharger : ICharger  
{  
    public void ChargeDevice()  
    {  
        Console.WriteLine("Charging with a wireless charger.");  
    }  
}  

// Step 3: Laptop Depends on the Abstraction (ICharger)
public class Laptop  
{  
    private readonly ICharger _charger;  

    // Injecting charger dependency via Constructor
    public Laptop(ICharger charger)  
    {  
        _charger = charger;  
    }  

    public void Charge()  
    {  
        _charger.ChargeDevice();  
    }  
}  

class Program  
{  
    static void Main()  
    {  
        // Step 4: Easily switch between different charger types
        ICharger wired = new WiredCharger();  
        Laptop laptop1 = new Laptop(wired);  
        laptop1.Charge();  

        ICharger wireless = new WirelessCharger();  
        Laptop laptop2 = new Laptop(wireless);  
        laptop2.Charge();  
    }  
}  
```

---

## **Key Improvements with DIP:**
✅ **Loosely Coupled Code**  
- `Laptop` does not depend on `WiredCharger` or `WirelessCharger`. It depends on `ICharger`, making it flexible.

✅ **Easily Extendable**  
- If we want to add a `SolarCharger`, we simply create a new class implementing `ICharger`, without modifying `Laptop`.

✅ **Better Unit Testing**  
- We can now mock `ICharger` for unit testing without relying on actual implementations.

```csharp
public class MockCharger : ICharger  
{  
    public void ChargeDevice()  
    {  
        Console.WriteLine("Mock charging for unit test.");  
    }  
}
```

---

## **Conclusion**
By following the **Dependency Inversion Principle**, we ensure that:  
- High-level modules (like `Laptop`) depend on **abstractions** (`ICharger`) rather than concrete implementations (`WiredCharger`, `WirelessCharger`).
- Code remains **flexible, maintainable, and testable**.  
- We can easily extend or modify behavior without changing existing classes.

This principle is particularly useful in enterprise applications and **Dependency Injection (DI) in .NET Core**, where we inject dependencies via interfaces.
